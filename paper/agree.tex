At the component level, the scheduling semantics can often be directly modeled in the AADL AGREE annex. This requires introducing two Boolean variables dispatch and complete, augmenting the original contracts with dispatch or complete, and adding additional guarantees to enforce the output freeze rule. We omit the assumptions of frozen inputs, as it is often trivia to check that they are guaranteed by the output freeze rule and the system-level assumptions.

\begin{figure}[ht!]
\centering
\includegraphics[width=130mm]{wpmAGREE3.jpg}
\caption{Modeling of Scheduling Semantics in AGREE\label{wpmAGREE}}
\end{figure}

Figure \ref{wpmAGREE} shows an example taken from an AADL model developed in the CASE project. The first two guarantees are added to freeze outputs between completions. And the original contracts (the assumption and the third guarantee) are augmented with dispatch and complete.
In practice, we find that direct modeling is helpful to clarify the semantics with users. However, in general it is a complex task, particularly if the contracts depend on past history. We rely on the Lustre backend model to handle the general case.

At the system-level, we use a circular counter to model a cyclic schedule in AGREE. 
The counter updates at every instant. Once it reaches the limit, it resets to one at the next instant.
We set the limit to the period of the schedule. 
%The counter is a direct encoding of schedule $\phi$ defined previously.
Based on the current count, the counter triggers a corresponding scheduling event.

\begin{figure}[ht!]
\centering
\includegraphics[width=80mm]{schedule.jpg}
\caption{Model of a Schedule in AGREE\label{schedule}}
\end{figure}

Figure \ref{schedule} shows an AGREE model of the schedule $(ABACD)$.

%An AGREE model of the schedule $(ABACD)^*$ used in the example is shown in code~\ref{schedule_model}

%\begin{lstlisting}[language=c,frame=single,caption=An AGREE model of a schedule,label=schedule_model]
%node CircularCounter (init: int, incr: int, reset: bool)	
%returns (count: int);
%let
%	count = if reset then init
%		else init-> (pre(count) + incr);
%tel;
%				
%eq tick : int = CircularCounter(1,1,prev(tick=10,false));
%
%assume "Schedule ABACD" :
%	A_dispatch = (tick = 1 or tick = 5) and
%	A_complete = (tick = 2 or tick = 6) and					
%	B_dispatch = (tick = 3) and	
%	B_complete = (tick = 4) and
%	C_dispatch = (tick = 7) and
%	C_complete = (tick = 8) and	
%	D_dispatch = (tick = 9) and
%	D_complete = (tick = 10);			
%\end{lstlisting}	

