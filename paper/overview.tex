Now we discuss in details our semantic interpretation of the AGREE contracts with scheduled components.
\begin{figure}[ht!]
\centering
\includegraphics[width=80mm]{pre.jpg}
\caption{A Simple Integrator AADL Model in AGREE\label{integratorFig}}
\end{figure}

First, we will explain our rationals. Consider the AADL model of an integrator, shown in Figure \ref{integratorFig}. We assume a processor time slot in a schedule is assigned to the thread.  
The first question we face is when the contracts shall hold. In a synchronous model, contracts hold at every instant. However, with scheduled execution, it is reasonable to assume the contract may not hold when the component is not activated. But once it is activated, shall they hold throughout the whole execution or just at certain instants? Second, how shall $Input$ referred in the contract be interpreted? One interpretation is that it refers to the input value at the time when the contract is evaluated, which may vary during the execution. Another interpretation is that it refers to the input value when the component starts its execution. In other words, there is a notion of \emph{sample and hold}. Any input value change during the execution will not impact the current execution. This interpretation is consistent with the notion of \emph{frozen} input described in the AADL V2 standard. Third, how the \emph{prev} operator shall be interpreted? In a synchronous model, it refers to the previous instant. However, with scheduled execution, it seems reasonable to interpret \emph{prev} as previous activation (i.e. the last value when the component was activated). If the contracts hold throughout the activation, a more sensible interpretation is that at the first instant during activation, it refers to the previous activation. Then at each following instant, it refers to the last updated value in the current activation. This interpretation is adopted in the \emph{activation condition} in SCADE \cite{scade} or the \emph{clock} mechanism in SIGNAL \cite{signal}.

AGREE contracts are intended to model requirements \cite{AGREE2}, not implementations. Guarantees model the component requirements, and assumptions models the environmental constraints used to verify the component requirements. Following the AADL \emph{input-compute-output} model, we interpret that the assumptions shall hold at the start of the execution (i.e. \emph{dispatch}) when the inputs are read in. And the guarantees shall be satisfied at the end of the execution (i.e. \emph{complete}) when the outputs are written out. This interpretation has a few implications. 
First, since we adopt the AADL frozen input concept, any reference to $Input$ refers to the input value that was read in at dispatch.
Second, a component's assigned time slot does not necessarily match exactly its execution time window. If the time slot is greater than its execution time, we interpret the start and end of the time slot as dispatch and complete, respectively. Otherwise, we interpret a preemption has occurred.
Third, each contract is examined exactly once in each activation. Thus, we interpret the $prev$ operator as the previous activation. 
This also means they do not model the \emph{transient} behavior during an execution. Instead, we interpret them as requirements on the \emph{steady-state} outputs at the end of activation.

%This is different from the real-time behavior models used to formalize AADL semantics, like real-time Maude \cite{maude}, timed automata \cite{behaviorannex}, and timed Petri net \cite{tpn}. They model the component timing behavior throughout the whole execution. 
Note that this does not mean AGREE contracts cannot model timer (or integrator) based requirements. In practice, a timer is usually implemented as a counter, whose limit (constant) is calculated based on the frequency of its execution. The counter is activated periodically and increments by only one during each activation, independent of the execution time. This is consistent with our interpretation.

Thus, we introudce two distinctive events \emph{dispatch} and \emph{complete} for each component to model the start and end of its activation, respectively. 
%Similarly, for a system (consists of components), the two events model the start and end of a scheduling cycle. 
The two events shall appear in pairs and alternately. \emph{dispatch} shall appear before \emph{complete}. We will introduce the notion of \emph{well-ordered} to capture the pattern.

In SCADE and SIGNAL, when a component is not activated, its outputs keep their previous values. We adopt the same output freeze semantics. The outputs will not change value between \emph{complete} events. 

We inherit the same notion of connection used in current AGREE. A connection between two components means their contracts refer to the same signal. 
This, combined with a schedule, essentially simulates an asynchronous communication between components with shared variable. It has one writer and possibly multiple readers. This is consistent with the AADL data port communication semantics.
Since the schedule ensures at most one component is activated at a time, there is no ambiguity on the order of read and write or the variable value. For a preemptive schedule, we require a component can only be preempted by another component if they do not have connections, which eliminates potential ambiguities.

The communication channel may also be viewed as a buffer or queue of size one. The writer overwrites when overflow occurs. The reader reads the last value if the queue is empty. This means the model only supports limited AADL event data port communication.

Following the AADL frozen inputs concept, we require the inputs values do not change while the component is activated. This implies the assumptions might be examined at \emph{complete}, instead of \emph{dispatch}. Thus, we may not need the \emph{dispatch} event. We keep both events mainly due to two considerations. First, the assumptions in general could depend on the past outputs. And outputs are updated at \emph{complete}. The outputs values at \emph{dispatch} may be different from \emph{complete}. Thus, it is important to distinguish the two instants to avoid ambiguity of the outputs values. Second, we find the pair helps users better understand the counterexample trace, particularly with a preemptive schedule.

%{\bf Model of Real-Time Schedule.}
In practice, a schedule often originally comes in form of a sequence of time slots associated with the components. 
The schedule could come from an AADL real-time scheduling tool like Cheddar \cite{cheddar}, or from a scheduler provided by the RTOS/Microkernel vendor, like seL4 \cite{sel4}. 
To properly model the schedule in AGREE, the component execution time has to be considered. Consider the example shown in Figure \ref{RTschedule}. There are two scheduled components $A$ and $B$. We refer the original schedule as real-time schedule. We refer its model in AGREE as AGREE schedule.
\begin{figure}[ht!]
\centering
\includegraphics[width=130mm]{RTschedule.jpg}
\caption{A Model of Real-Time Schedule in AGREE\label{RTschedule}}
\end{figure}
Given the same real-time schedule, due to the different execution time $C_A$ of $A$, two different AGREE schedules are created. In Figure \ref{RTschedule}(a), since $C_A$ is equal to the time slots assigned to $A$, the end of the each time slot is modeled as \emph{complete}. In Figure \ref{RTschedule}(b), since the first time slot assigned to $A$ is less than its execution time, the end of the first time slot is interpreted as \emph{preemption}, instead of \emph{complete}.

%The AGREE reasoning framework uses past-time LTL [2], particularly LTL operator $G$ (globally), $H$ (historically), and $Z$ (previous). Given a component with an assume-guarantee pair ($A,P$) and an event pair (\emph{dispatch}, \emph{complete}), the meaning of the contract can be formally represented as a past-time LTL formula $G(H((dispatch \Rightarrow A)) \Rightarrow (complete \Rightarrow P))$. In synchronous AGREE, the two events \emph{collpase} into a single instant at each tick. Thus, we have $G(H(A) \Rightarrow P)$.

%{\bf External Input.} 
The system-level inputs may come from the physical environment or another system. We assume the arrival time of the inputs is \emph{managed}, so that the inputs values do not change when the receiving component is activated. This means there may exist a buffer mechanism that stores all the input messages in a queue and periodically send it out to the components for processing. % We assume the communication can be modelled as a shared variable, and the communication rate is the same as the system execution rate. 

