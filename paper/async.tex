{\bf Signal.}
A signal $x$ is a function $x: N \rightarrow V$, where $N$ is the set of natural numbers including zero, and $V$ is a value set. 
A signal is \emph{Boolean} if the value set is the Boolean domain.
We use $x(n)$ to denote the value of the signal $x$ at instant $n$. 
%A \emph{trace} $\sigma_x$ of a signal $x$ is a possibly infinite sequence of values $(x(1), x(2),... )$. 
%We use $X_V$ to denote the set of all possible signals for a value set $V$.
%The \emph{length} of a trace is the number of elements in the sequence. 
%The length-$k$ trace of a signal $x$ is denoted as $x^k$.
%The set of the length-$k$ traces of a set $X$ of signals is denoted as $X^k$.
%The set of all possible traces of a signal $x$ is denoted as $x^{\omega}$. 
%The set of all possible traces of a set $X$ of signals is denoted as $X^{\omega}$. 

{\bf Port.}
%Let $Q ={q_1, ...,q_M}$ be a set of ports, where $q_i$ is the name of the i-th port. 
Let $Q$  be a set of ports. 
For each port $q \in Q$, a set $V_q$ denotes the values that may be assigned to port $q$. %$V_q$ is called the type of port $q$. 
%A \emph{valuation} of $Q$ is an assignment of a value in $V_q$ to each port $q \in Q$.
A signal $x_q$ of a port $q$ is a function $x_q: N \rightarrow V_q$.
A \emph{trace} $\sigma_Q$ of ports $Q$ is an assignment of a signal $x_q$ to each port $q$ in $Q$.
We use $\Sigma_Q$ to denote the set of all traces of ports $Q$.
Given a set $Q' \subseteq Q$, the \emph{projection} of a trace $\sigma_Q$ onto ports $Q'$ is the assignment of signal $x_q$ to each port $q$ in $Q'$ defined in $\sigma_Q$, as defined in $\sigma_Q$. We denote the projection as $\sigma_Q|_{Q'}$.   
 
{\bf Dispatch and Complete.}
Two Boolean signals \emph{dispatch} and \emph{complete} are \emph{well-ordered} if 

\begin{enumerate}
%	\item $ \nexists n\in N, dispatch(n) = 1 \text{ and } complete(n) =  1 $, 
	\item $\forall n \in N, dispatch(n) \ne 1 \vee complete(n) \ne 1 $,
	\item $ \forall n\in N, dispatch(n) = 1 \Rightarrow \exists m\in N, m > n, complete(m) =  1 $,
	\item $ \forall m\in N, complete(m) = 1 \Rightarrow \exists n\in N, m > n, dispatch(n) =  1 $,
	\item $ \forall n,m\in N, n \neq m, dispatch(n) = 1, dispatch(m) = 1 \Rightarrow \exists k\in N, m >k> n, complete(k) = 1 $.
\end{enumerate}

The first condition states that \emph{dispatch} and \emph{complete} are mutual exclusive. The second and third condition state that \emph{dispatch} and \emph{complete} appear in pairs, and in each pair \emph{dispatch} appears before \emph{complete}. The fourth condition states that \emph{dispatch} and \emph{complete} appear alternately. 
From hereon we only consider a well-ordered pair (\emph{dispatch}, \emph{complete}).

An \emph{interval} $\delta$ of a pair (\emph{dispatch}, \emph{complete}) is a closed interval $[n, m], n,m \in N, m>n$, satisfying:

\begin{enumerate}
	\item $ dispatch(n) = 1 $, 
	\item $ complete(m) = 1 $, 
	\item $ \forall k\in (n, m), dispatch(k)=0 \wedge complete(k)=0 $.
\end{enumerate}

We denote the set of all intervals as $\Delta$.

{\bf Component.}
A component $c$ is a tuple $(I_c, O_c, A_c, P_c, dispatch_c, complete_c)$, where: 

\begin{itemize}
    	\item $I_c$ is a finite set of ports, called \emph{inputs},
    	\item $O_c$ is a finite set of ports disjoint from $I_c$, called \emph{outputs},
%	\item $\Sigma_c \subseteq \Sigma_{I_c \cup O_c}$, called behavior,
%	\item $A_c$ and $P_c$ are prefix-closed subsets of $(I_c \cup O_c)^\omega$, called \emph{assumptions} and \emph{guarantees}, respectively,
%	\item $A_c$ and $P_c$ are two Boolean functions $(I_c \cup O_c)^\omega \rightarrow B$, called \emph{assumptions} and \emph{guarantees}, respectively,	
	\item $A_c$ and $P_c$ are two Boolean functions $\Sigma_{I_c \cup O_c} \rightarrow B$, called \emph{assumptions} and \emph{guarantees}, respectively,	
    	\item ($dispatch_c$, $complete_c$) is a pair of \emph{well-ordered} Boolean signals.
\end{itemize}
%A \emph{trace} $\sigma_c$ of a component $c$ is an assignment of a signal $x_q$ to each port $q$ in $I \cup O$.

%Let $\mathcal{A}_c$ be a function $(I_c \cup O_c)^\omega \rightarrow B$, such that $\forall \Sigma \in A_c, \mathcal{A}_c(\Sigma) = 1$.
%Let $\mathcal{P}_c$ be a function $(I_c \cup O_c)^\omega \rightarrow B$, such that $\forall \Sigma \in P_c, \mathcal{P}_c(\Sigma) = 1$.

%A component is said to be \emph{consistent} if it satisfies the following rules.
%A component satisfies the following rules.
%Given a component $c$ and a trace $\sigma_c \in \Sigma_{I_c \cup O_c}$, we define the following propositions:

The \emph{behavior} of a component $c$ is a set $\Sigma_c \subseteq \Sigma_{I_c \cup O_c}$, such that for all trace $\sigma_c \in \Sigma_c$ the following propositions hold.
%A component $c$ is said to be \emph{consistent} if for all $\sigma_c \in \Sigma_c$ the following propositions hold.

The \emph{assumptions} hold at \emph{dispatch}. That is,
\begin{equation} 
\label{eqn:assumption}
%	dispatch_c(n) \Rightarrow A((I_c \cup O_c)^n), \forall n\in N.
	dispatch_c(n) \Rightarrow (\sigma_c, n) \models A_c, \forall n\in N.
\end{equation}

Inputs freeze between \emph{dispatch} and \emph{complete}. That is,
\begin{equation} 
\label{eqn:inputfreeze}
	x(i) = x(j), \forall i,j\in \delta \cap N, \forall \delta \in \Delta, \forall x \in \sigma_c|_{I_c}.
\end{equation}

The \emph{guarantees} hold at \emph{complete}. That is,
\begin{equation} 
\label{eqn:guarantee}
%	complete_c(n) \Rightarrow P((I_c \cup O_c)^n), \forall n\in N.
	complete_c(n) \Rightarrow (\sigma_c, n) \models P_c, \forall n\in N.
\end{equation}

Outputs freeze between \emph{completes}. That is,
\begin{equation} 
\label{eqn:outputfreeze}
\lnot complete_c(n) \Rightarrow y(n) = y(n-1), \forall n \in N, n > 0, \forall y \in \sigma_c|_{O_c}.
\end{equation}

{\bf Schedule.}
Two components $ c, c', c\neq c'$ are said to be \emph{connected} if
\begin{equation*}
	O_c \cap I_{c'} \neq \emptyset \vee O_{c'} \cap I_c \neq \emptyset.
\end{equation*}

Let $C$ be a finite set of components, a schedule $\phi$ of $C$ with \emph{length} $T\in N$ is a partial function $[1, T]  \cap N\rightarrow C\times \{\textsf{Dispatch}, \textsf{Complete}\}$ satisfying:

\begin{enumerate}
	\item $ \forall i\in \text{dom }\phi, c\in C, \phi(i) = (c, \textsf{Dispatch}) \Rightarrow \exists j\in \text{dom }\phi, j > i, \phi(j) =  (c, \textsf{Complete}) $,
	\item $ \forall j\in \text{dom }\phi, c\in C, \phi(j) = (c, \textsf{Complete}) \Rightarrow \exists i\in \text{dom }\phi, j > i, \phi(i) =  (c, \textsf{Dispatch}) $,
	\item $ \forall i, j\in \text{dom }\phi, c\in C, i \neq j, \phi(i) = (c, \textsf{Dispatch}), \phi(j) = (c, \textsf{Dispatch}) \Rightarrow \exists k\in \text{dom }\phi, j >k> i, \phi(j) =  (c, \textsf{Complete}) $,
	\item $ \forall i, j, n\in \text{dom }\phi, i < n < j, c, c'\in C, \phi(i) = (c, \textsf{Dispatch}), \phi(n) = (c', \textsf{Dispatch}), \phi(j) = (c, \textsf{Complete}) \Rightarrow c, c' \text{ are not connected, and }\exists m\in \text{dom }\phi, n < m < j, \phi(m) =  (c', \textsf{Complete}) $.
\end{enumerate}

The first three conditions ensure the pair (\textsf{Dispatch}, \textsf{Complete}) associated with a component is \emph{well-ordered} in a schedule. 
The fourth condition allows a component to be \emph{preempted} by another component if they two have no connection.
If the schedule is not preemptive, we could simplify the notation and denote a schedule as a function that maps $[1, T] \cap N$ to $C$, as shown in the previous examples.
A schedule is \emph{minimal} if $\phi$ is a \emph{total} function. This means that at each instant either a \emph{dispatch} or a \emph{complete} signal evaluates to true. 
A schedule is \emph{fair} if $\phi$ is \emph{surjective}. This means that every component is scheduled to execute at least once.
%In our framework, we only consider fair schedules.

Given a schedule $\phi$ of components $C$, the \emph{dispatch} and \emph{complete} signal of a component $c \in C$ are defined as follows: $\forall i \in N$,
\begin{equation*}
\label{eqn:dispatch}
    dispatch_c^\phi(i) =
    \begin{cases}
      1, & \text{if } \phi(i \mod T) = (c, \textsf{Dispatch}) \\
      0, & \text{otherwise}
    \end{cases},
\end{equation*}

\begin{equation*}
\label{eqn:complete}
    complete_c^\phi(i) =
    \begin{cases}
      1, & \text{if } \phi(i \mod T) = (c, \textsf{Complete}) \\
      0, & \text{otherwise}
    \end{cases}.
\end{equation*}

{\bf System.}
A set $C$ of components are said to be \emph{compatible} if 

\begin{equation*}
\forall c_i,c_j \in C, c_i\neq c_j, O_{c_i} \cap O_{c_j} = \emptyset.
\end{equation*}

A set $C$ of components are said to be \emph{connected} if
\begin{equation*}
\forall c_i \in C, \exists c_j \in C, c_i\neq c_j, O_{c_i} \cap I_{c_j} \neq \emptyset \vee O_{c_j} \cap I_{c_i} \neq \emptyset.
\end{equation*}

A set $C$ of compatible, connected, scheduled components is a \emph{system} $S = (I_s, O_s, A_s, P_s, \phi, dispatch_s, complete_s)$, where:
\begin{itemize}
	\item $I_s = \cup_{\forall c \in C}I_c -  \cup_{\forall c \in C}O_c$,
	\item $O_s = \cup_{\forall c \in C}O_c$,
	\item $A_s$ and $P_s$ are system-level \emph{assumptions} and \emph{guarantees}, respectively,
	\item $\phi$ is a schedule of $C$,	
	\item $dispatch_s^\phi (i) = 
	    	\begin{cases}
      		1, & \text{if}\ i \mod T =1 \\
	     	0, & \text{otherwise}
   	 	\end{cases}, \forall i \in N$,
   	\item $complete_s^\phi (i) =
   		\begin{cases}
      		1, & \text{if}\ i \mod T = 0 \\
	     	0, & \text{otherwise}
   	 	\end{cases}, \forall i \in N, i > 0$.
\end{itemize}

We use $\delta_s$ to denote an \emph{interval} of the pair ($dispatch_s^\phi, complete_s^\phi$). We use $\Delta_s$ to denote the set of all such intervals.

The \emph{behavior} of a system $s$ is a set $\Sigma_s \subseteq \Sigma_{I_s \cup O_s}$, such that for all trace $\sigma_s \in \Sigma_s$ the following propositions hold.

We define the following propositions.

The \emph{assumptions} hold at \emph{dispatch}. That is,
\begin{equation} 
\label{eqn:assumption}
dispatch_s^\phi(n) \Rightarrow (\sigma_s, n) \models A_s, \forall n\in N.
\end{equation}

Inputs freeze between dispatch and complete. That is,
\begin{equation} 
\label{eqn:inputfreeze}
x(i) = x(j), \forall i,j\in \delta_s \cap N, \forall \delta_s \in \Delta_s, \forall x \in \sigma_s|_{I_s}.
\end{equation}

The \emph{gurarantees} hold at \emph{complete}. That is,
\begin{equation} 
\label{eqn:guarantee}
complete_s^\phi(n) \Rightarrow (\sigma_s, n) \models P_s, \forall n\in N.
\end{equation}
