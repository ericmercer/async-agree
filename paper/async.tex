
First, we describe the rational behind our semantics interpretation of an AADL model in AGREE with a schedule. Then, we formally define the scheduling semantics of AGREE and discuss their connection to AADL semantics.

\begin{figure}[ht!]
\centering
\includegraphics[width=80mm]{pre.jpg}
\caption{A Simple Integrator AADL Model in AGREE\label{integratorFig}}
\end{figure}

We use an example to illustrate our rationals. Consider a simple model of integer integrator shown in Figure \ref{integratorFig}. Let us assume a time slot in a periodic schedule is allocated to the component.  
%The first problem we face is how to interpret the contracts with the time slot. 
The first question we have is when the contracts hold. In a synchronous model, contracts hold at every \emph{tick}. However, with scheduled execution, it is reasonable to assume the contract may not hold when the component is not \emph{active}. But once it is active, shall it hold throughout the whole execution or just at certain instants? Second, how shall $Input$ referred in the contract be interpreted? One interpretation is that it refers to the input value at the time when the contract is evaluated, which may vary during the execution. Another interpretation is that it refers to the input value when the component starts its execution. In other words, there is a notion of \emph{sample and hold}. Any input value change during the execution will not impact the current execution. This interpretation is consistent with the notion of \emph{frozen} input in AADL. Third, how the \emph{pre} operator shall be interpreted? In a synchronous model, it refers to the previous \emph{tick}. However, with scheduled execution, it seems reasonable to interpret \emph{pre} as previous activation (i.e. the last value when the component was active). The interpretation makes sense if the contract holds at only one instant during the execution. If the contract holds at multiple instants, a more sensible interpretation is that at the first instant, it refers to the previous activation. Then at each following instant, it refers to the last updated value in the current execution. This interpretation is adopted in the \emph{activation condition} in SCADE \cite{scade} or the \emph{clock} mechanism in SIGNAL \cite{signal}.

%This interpretation means that the number of evaluation during the execution could have an impact on the final output value. This is illustrated in the integrator example. To match the software behavior, the evaluation interval has to equal the integration step size used in the implementation. 

%In AGREE, the contracts represent requirements and we want to comply with AADL semantics. This has some implictions.  In AADL, inputs are frozen at dispatch time by default. Thus, we interpret the input referred in a contract as the input value at dispatch time. And assumptions on input or its history hold at dispatch time. 
%
%We assume dispatch occurs at the beginning of the time slot and complete occurs at the end. For now, we assume there is no preemption. We will discuss how preemption is handled in Section 4. Note that we use complete to refer to the end of a time slot. It does not necessarily mean the actual execution ends exactly at the end of the time slot. We interpret it as the upperbound of worst case execution time plus some margin. In other words, this is time for sure the computation is complete and the final output data is available. Note that in acutual implementation the output value may vary during the execution. We interpret guarantees as requrirements on the final output. 

In AGREE, the contracts are intended to model requirements \cite{AGREE2}. Assumptions and guarantees correspond to preconditions and postconditions, respectively. Given the AADL \emph{input-compute-output} model, we interpret that the assumptions shall hold at the start of the execution when the inputs are read in. And the guarantees shall be satisfied at the end of the execution when the outputs are written out. In other words, the AGREE contracts are not intended to model the timing behavior within an execution. This is different from the real-time behavior models used to formalize AADL semantics, like real-time Maude \cite{maude}, timed automata \cite{behaviorannex}, and timed Petri net \cite{tpn}. They model the component timing behavior throughout the whole execution. Note that since each contract is evaluated exactly once in each activation, the $pre$ operator is interpreted as previous activation. We adopt the AADL frozen input semantics, so any reference to $Input$ refer to the same input value.

Note that this does not mean AGREE contracts cannot model timer (or integerator)-like requirements. In practice, a timer is usually implemented as a counter, whose limit (constant) is calculated based on the frequency of its execution. The counter is active periodically and increments by only one during each activation, independent of the execution time. 

Thus, in our interpretation, the length of the execution time at each activation, which could vary from one activation to another, is abstracted out. We introudce two distinctive events \emph{dispatch} and \emph{complete} for each component to model the start and end of its each execution, respectively. Similarly, for a system (consists of components), they model the start and end of a scheduling cycle.
The two events shall appear in pairs and alternately. \emph{dispatch} shall appear \emph{before} \emph{complete}. We define \emph{well-orderedness} to capture the pattern.

The AGREE reasoning framework uses past-time LTL [2], particularly LTL operator $G$ (globally), $H$ (historically), and $Z$ (previous). Given a component with an assume-gurantee pair ($A,P$) and an event pair (\emph{dispatch}, \emph{complete}), the meaning of the contract can be formally represented as a past-time LTL formula $G(H((dispatch \Rightarrow A)) \Rightarrow (complete \Rightarrow P))$. In synchronous AGREE, the two events \emph{collpase} into a single instant at each tick. Thus, we have $G(H(A) \Rightarrow P)$.

We use \emph{state} to represent the history of both inputs and outputs streams. The state transition depends on both inputs and outputs. This is because AGREE \emph{Guarantee} contracts usually do not completely define the outputs based on the inputs and states. Instead, they impose contraints that all valid outputs shall satisfy.

%In the formal definition, we use indices to represent the total order of scheduling events. TODO

%A system consists of components, connections between components, contracts, and a schedule.
%The schedule defines a total order of dispatch and complete events of each component within a scheduling cycle.
%A valid schedule is one where component activations do not overlap.
%Once a component is activated, it runs to complete. There is no preemption.
%A component reads input at dispatch time. %Reading is non-blocking. It reads the most recent input data value or an initial value. 
%And the input is \emph{frozen} during the component activation.
%A component writes output at completion time. %Writing is non-blocking. It overwrites the previous data value. 
%And the output holds its data value between its completions.
%The connections represent an asynchrnous communication channel with a buffer of size one.
%The connections between components are unidirectional. %It represents communication through shared variable with one writer and possible multiple readers. 
%A component satisfies its assumptions at dispatch time. %If the assumption is violated, then the system is consided \emph{inconsistent}.
%A component satisfies its guarantees at completion time. 
%And the output holds its data value between its completions.

{\bf Signal.}
A signal $x$ is a function $x: N \mapsto T_x$, where $N$ is the set of natural numbers including zero, and $T_x$ is the data type of $x(n)$ for all $n \in N$.
$x(n)$, an assignment of a vlaue in $T_x$ to $x$, is called a \emph{valuation} of signal $x$. 
A \emph{trace} of a signal $x$ is a possibly infinite sequence of valuations $(x(0), x(1), x(2),... )$. 
The \emph{length} of a trace is the number of elements in the sequence. 
The set of all traces of length $k$ of a signal $x$ is denoted as $x^k$. 
The set of all possible traces of a signal $x$ is denoted as $x^{\omega}$. 
%We may refer a Boolean signal as an \emph{event}.
%The data type can be either a primitive data type (e.g. real, bool, int, and enumeration types) or a composite data type (e.g. record types). 
%Assume the data type of signal $x$ and $y$ is $T_x$ and $T_y$, respectively, $x = y$ means that $T_x=T_y$ and $x_i = y_i$ for all $i \in N$. 

%{\bf Port.}
%$Y$ is a set of typed ports. A \emph{valuation or snapshot} of ports is a function that maps each port to a value: $y  \mpasto T_y$.
%That is, $I(n) = \{x_1(n), x_2(n), ... x_N(n)\}$, where $n \in N$. Each port $x \in X$ is associated with a signal. 
%To simplify the notation, we use the port ID $x$ to denote the associated \emph{signal}. Outputs are defined similarly: $Y = \{y_1, y_2, ..., y_K\}$, where $K\in N$ is the total number of output ports.  
% Similarly, a \emph{valuation} of output ports $O(n) = \{y_1(n), y_2(n), ... y_N(n)\}$, where $n \in N$. 

%We model the AADL ports as signals. In particular, an event port is modelled as a Boolean signal. The value \emph{1} or \emph{0} indicates the event is \emph{present} or \emph{absent} at the port, respectively. 
%An event data port is modelled as a pair of data signal and event signal.  %An event data port is modelled as a pair of data signal $p$ and event signal $event(p)$.  

{\bf Dispatch and Complete.}
Two Boolean signals \emph{dispatch} and \emph{complete} are \emph{well-ordered} if 
\begin{enumerate}
	\item there eixsts no $n\in N$ such that $dispatch(n) = 1$ and $complete(n) =  1$.
	\item there exists $n\in N$ such that $dispatch(n) = 1$ if and only if there exists $m\in N$, such that $m > n, complete(m) =  1$.
	\item if there exists $n,m\in N, n \neq m$ such that $dispatch(n) = 1, dispatch(m) = 1$, then there exists $k\in N, m >k> n$ such that $complete(k) = 1$.
\end{enumerate}
The first condition states that \emph{dispatch} and \emph{complete} are mutual exclusive. The second condition states that \emph{dispatch} and \emph{complete} appear in pairs, and in each pair \emph{dispatch} appears before \emph{complete}. The third condition states that \emph{dispatch} and \emph{complete} appear alternately. 
%A pair of well-ordered ($dispatch$, $complete$) signals defines a sequence of \emph{intervals}. 
$[n, m], n,m \in N$ is an \emph{interval} of a pair of well-ordered $dispatch$ and $complet$e if $dispatch(n) = 1$, $complete(m) = 1$, and $\forall k\in (n, m], dispatch(k)=0$. We denote the interval as $\delta(n)$.

{\bf Component.}
%A component $c$ is a nine-tuple $(S, s_0, I, O, \delta, A, P, dispatch, complete)$, where: 
A component $c$ is a six-tuple $(I, O, A, P, dispatch, complete)$, where: 
\begin{itemize}
%    	\item $S$ is a finite non-empty set of states;
%    	\item $s_0 \in S$ is the initial state;
    	\item $I = \{x_1, x_2, ..., x_g\}$ is the set of input signals;
    	\item $O= \{y_1, y_2, ..., y_h\}$ is the set of output signals disjoint from $I$;
%    	\item $\delta$ is the state transfer function of the form $\delta: I \times O \times S \mapsto S$;
 	\item $A$ is a set of \emph{assumptions}, for all $a \in A$, $a$ is a Boolan function $I^{\omega} \mapsto B$;
 	\item $P$ is a set of \emph{gurarantees}, for all $p \in P$, $p$ is a Boolan function $I^{\omega} \times O^{\omega} \mapsto B$;
%  	\item $A$ is a set of \emph{assumptions}, for all $a \in A$, $a$ is a Boolan function $I \times S \mapsto B$;
%  	\item $P$ is a set of \emph{gurarantees}, for all $p \in P$, $p$ is a Boolan function $I \times O \times S \mapsto B$;
    	\item $dispatch$ and $complete$ are a pair of \emph{well-ordered} Boolean signals.
%	\item $complete$ is a Boolean signal.
%	\item $clock$ is a Boolean signal $clock(n) \Rightarrow \lnot clock(n+1) \land  \lnot clock(n-1), \forall i \in N$ .
\end{itemize}
%We use $a_n$ and $p_n$ to denote the function $a$ and $p$ with signals of length $n$, respectively. 
%Note that the guarantees represent a general relation, not a function. This allows users to models the non-derterminism introduced by design decision or implementation choice.
%The ports of a thread are divided into two finite disctinct sets: input ports ($I$) and output ports ($O$). Correspondingly, the associated signals are divided int to input signals and output signals. We model the \emph{state} of a thread with a finite set $S$ of signals. %The next state function is $T: S x I \mapsto S'$. The output function is $T: S x I \mapsto S$. Then, a thread is %A thread is modelled as a collection of input signals and output signals. A thread could be aossciated with /emph{local} states, which are not accessible outside the scope of the thread. They are modelled as signals, noted as set S . 
%{\bf component execution.}
%A component is associated with two Boolean signals (events) \emph{dispatch} ($d$) and \emph{complete} ($c$). A component is \emph{dispatched} at time $i$, if and only if $d(i) = true$. A component is \emph{complete} at time $i$, if and only if $c(i) = true$. %A component can be in either \emph{active} or \emph{sleep} mode. 
%At \emph{dispatch} a component evaluates the inputs. At \emph{complete}, it updates its output and transitions to its \emph{next state}. After \emph{complete}, it holds its state and output till next \emph{complete}. That is,
%A \emph{valuation} of an assumption $a$ is defined as $a(n) =  a(I(n), s(n))$.
%A \emph{valuation} of a gurarantee $p$ is defined as $p(n) =  p(I(n), O(n), s(n))$.
A component satisfies the following rules.

The \emph{assumptions} hold at \emph{dispatch}. That is,
\begin{equation} 
\label{eqn:assumption}
%dispatch(n) \Rightarrow a(I(n), s(n)), \forall n\in N, \forall a \in A
dispatch(n) \Rightarrow a(I^n), \forall n\in N, \forall a \in A
\end{equation}
%where $I^n = ({x_1}^n, {x_2}^n,..., {x_g}^n)$.

Inputs freeze between dispatch and complete. That is,
\begin{equation} 
\label{eqn:inputfreeze}
dispatch(n) \Rightarrow (x(i) = x(j)), \forall i,j\in \delta(n), \forall x \in I
\end{equation}

The \emph{gurarantees} hold at \emph{complete}. That is,
\begin{equation} 
\label{eqn:guarantee}
%complete(n) \Rightarrow p(I(n), O(n), s(n)), \forall n\in N, \forall p \in P
complete(n) \Rightarrow p(I^n, O^n), \forall n\in N, \forall p \in P
\end{equation}
%where $O^n = ({y_1}^n, {y_2}^n,..., {y_h}^n)$.

Outputs freeze between \emph{completes}. That is,
\begin{equation} 
\label{eqn:outputfreeze}
\lnot complete(n) \Rightarrow (y(n) = y(n-1)), \forall n \in N, n>0, \forall y \in O
\end{equation}

%Let $s$ be a \emph{valuation} of $S$. That is, $s: N \mapsto S$. 
%\begin{equation} 
%\label{eqn:statetransfer}
%complete(n) \Rightarrow s(n) = \delta (s(n-1), I(n-1), O(n-1), \forall n \in N, \forall s \in S
%\end{equation}

%\begin{equation} 
%\label{eqn:statehold}
%\lnot complete(n) \Rightarrow s(n) = s(n-1), \forall n \in N, \forall s \in S
%\end{equation}

%The \emph{dispatch} and \emph{complete} models, respectively, the start and end of the time slot that a component to run. 
%When its \emph{dispatch} event $d$ is present, a thread samples the input values and starts execution. This is the time when the associated AGREE \emph{assumptions} $A$ should hold. That is,
%$$event(d)_i \Rightarrow a_i, \forall i\in N, \forall a \in A $$

{\bf Trace.}
A \emph{snapshot} of a component is a valuation of its inputs, outputs, dispatch, and complete signals. %That is, $c(n) = \{I(n),O(n),dispatch(n),complete(n)\}, \forall n\in N$.
A \emph{trace} of a component is a possibly infinite sequence of snapshots %$(c(0), c(1), c(2),... )$
%A trace $\sigma$ of a component $c(S, s_0, I, O, \delta, A, P, dispatch, complete)$ is a function of the form $\sigma: N \mapsto \Sigma$, where
%A trace $\sigma$ of a component $c(I, O, A, P, dispatch, complete)$ is function $\sigma: N \mapsto \Sigma$, where
%$\sigma(n) = ((I(n), O(n),dispatch(n), complete(n))$, for all $n\in N$, 
that satifies Equation \ref{eqn:assumption},  \ref{eqn:inputfreeze}, \ref{eqn:guarantee}, and \ref{eqn:outputfreeze}. %We denote the set of all traces of a component as $\Sigma$.
%A trace is a possibly infinite sequence of component valuations that satify the contract constraints and the input, output and state hold rules.  
The set of all traces of a component $c$ is called its \emph{language}, denoted as $L(c)$.

%{\bf Connection.}
%If an output signal $y$ of a component $c$ is \emph{connected} to an input signal $x'$ of a component $c', c' \neq c$, then $y = x'$. That is,
%A \emph{connection} from output signals $O$ of a component $c$ to input signals $I'$ of a component $c', c' \neq c$ is function: $e: I'\mapsto P(O)$. That is,
%Given two connected components $c_1=(I_1, O_1, A_1, P_1$ and $c_2$, where
%\begin{equation*}
%I = I \bigcup I' \backslash \{x'\}
 %O = O \bigcup O'
%A = A \bigcup A'
%P = P \bigcup P'
%\end{equation*}

%In AGREE, we have
%\begin{equation} 
%\label{eqn:connection}
%e(y, x') \Rightarrow y = x', \forall y \in Y, \forall x \in X'
%\end{equation} 
%where 

%A \emph{connection} from an output port of one component to an input port of another component implies the corresponding signals are equal. For an AADL event data prot, this means the data signals and event signals are equal, respectively. 

%The trace of the simple downsampling system is shown in Table \ref{tab:table1}.
%\begin{table}[h!]
%\begin{center}
%\caption{A Simple Downsampling System Trace}
%\label{tab:table2}
%\begin{tabular}{ |c|c|c|c|c|c|c|c|c|c|c|c| } 
%\hline
%k & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
%\hline
%a(k) & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
%\hline
%b(k) & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
%\hline
%c(k) & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
%\hline
%d(k) & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\
%\hline
%\end{tabular}
%\end{center}
%\end{table}}

{\bf Schedule.}
Let $C$ be a finite set of components, a schedule $\phi$ of $C$ with \emph{length} $T\in N$ is a partial function $T \mapsto C\times \{Dispatch, Complete\}$ satisfying:
\begin{itemize}
	\item there exists $i\in T$, $c\in C$ such that $\phi(i) = (c, Dispatch)$ if and only if there exists $j\in T$, such that $j > i, \phi(j) =  (c, Complete)$;
	\item if there exists $i, j\in T$, $c\in C$ such that $i \neq j, \phi(i) = (c, Dispatch), \phi(j) = (c, Dispatch)$, then there exists $k\in T$, such that $j >k> i, \phi(j) =  (c, Complete)$;
	\item if there exists $i, j, n\in T$, $c, c'\in C$ such that $i < n < j, \phi(i) = (c, Dispatch), \phi(n) = (c', Dispatch), \phi(j) = (c, Complete)$, then there exists $m\in T$, such that $n < m < j, \phi(m) =  (c', Complete)$ and $c$ and $c'$ have no connection.
\end{itemize}
The first condition requires that in a schedule \emph{Dispatch} and \emph{Complete} of a component must appear in pairs, and in each pair \emph{Dispatch} appears before \emph{Complete}. 
The second condition states that \emph{Dispatch} and \emph{Complete} of a component must appear alternately in a schedule. 
The third condition allows a component to be \emph{preempted} by another component if they two have no coonection.
Given a schedule $\phi$ of components $C$, the \emph{dispatch} and \emph{complete} signal of a component $c \in C$ are defined as follows: 
\begin{equation}
\label{eqn:dispatch}
    dispatch(i+kT) =
    \begin{cases}
      1, & \text{if}\ \phi(i) = (c, Dispatch) \\
      0, & \text{otherwise}
    \end{cases}
\end{equation}

\begin{equation}
\label{eqn:complete}
    complete(i+kT) =
    \begin{cases}
      1, & \text{if}\ \phi(i) = (c, Complete) \\
      0, & \text{otherwise}
    \end{cases}
\end{equation}

where $i,k\in N$.
A schedule is \emph{fair} if $\phi$ is \emph{surjective}. This means that every component is executed at least once.
A schedule is \emph{minimal} if $\phi$ is a \emph{total} function. This means that at each ``tick'' there is a \emph{dispatch} or \emph{complete} event. 
%Note in a synchronous model, a tick represents a global clock that triggers all components to update. While in the proposed model, ticks are used to represent the total order of events. 

With the frozen outputs, the \emph{connection} definition, and the scheduling semantics, we essentially define an asynchronous communication between components with shared variable. It has one writer and possibly multiple readers. Since the schedule ensures at most one component is active at a time, there is no ambiguity on the order of read and write. The comminucation may be viewed as a queue of size one, which has exactly one writer and one reader. The writer overwrites when overflow occurs. The reader reads the last value if the queue is empty.

{\bf System.}
A set $C$ of components are said to be \emph{compatible} if 
\begin{equation*}
\forall c_i,c_j \in C, i\neq j, O(c_i) \cap O(c_j) = \emptyset 
\end{equation*}

A \emph{system} is a triple $(C, \phi)$, where:
\begin{itemize}
    	\item $C$ is a finite set of compatible components;
%    	\item $E$ is a set of connections;
    	\item $\phi$ is a schedule.
\end{itemize}

\begin{equation*}
I(A) = \cup_{c_i \in C}I(c_i) -  \cup_{c_i \in C}O(c_i)
\end{equation*}

\begin{equation*}
O(A) = \cup_{c_i \in C}O(c_i)
\end{equation*}

%A \emph{trace} of a system is a trace of it components that satisfies the connection Equation \ref{eqn:connection} for all $e in E$, and the schedule Equation \ref{eqn:dispatch} and Equation \ref{eqn:complete}.

A trace of the simple downsampling system is partially shown in Table \ref{tab:table1}. For simplicity, we use one symbol to represent the input and output signals that are connected.
\begin{table}[h!]
\begin{center}
\caption{A Trace of the Simple Downsampling System}
\label{tab:table1}
\begin{tabular}{ |c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|c|} 
\hline
            k & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10  & 11 & 12 & 13 & 14 & 15 & 16 & 17 & 18 & 19 \\
\hline
dispatchA  & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0  \\ 
\hline
completeA & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0  \\ 
\hline
dispatchB & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0  \\ 
\hline
completeB & 0 & 0 & 0 &0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ 
\hline
dispatchC & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0  \\ 
\hline
completeC & 0 & 0 & 0 & 1  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 \\ 
\hline
dispatchD & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ 
\hline
completeD & 0 & 0 & 0 & 0  & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ 
\hline
a(k) & 0 & 1 & 1 & 1 & 1 & 2 & 2 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 4 & 4 & 4 & 4 & 4 \\
\hline
pre(a)(k) & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 2 & 2 & 2 & 2 & 3 & 3 & 3 & 3 & 3 \\
\hline
b(k) & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 2 & 4 & 4 & 4 \\
\hline
c(k) & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 3 & 3 & 3 & 3 & 3 & 3 & 3 \\
\hline
d(k) & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
\hline
\end{tabular}
\end{center}
\end{table}

{\bf Assume-Guarantee Reasoning.}
Given a system and a set of system \emph{assumptions} $A_s$ and a \emph{guarantee} $p_s$, a \emph{trace} of the contract is a sequence of inputs and outputs valuations that satisfies:

\begin{equation} 
\label{eqn:sys_assumption}
dispatch_s(n) \Rightarrow a_s(n), \forall n\in N, \forall a_s \in A_s
\end{equation}

\begin{equation} 
\label{eqn:sys_assumption}
complete_s(n) \Rightarrow p_s(n), \forall n\in N
\end{equation}

where:
\begin{equation}
\label{eqn:sys_dispatch}
    dispatch_s(n) =
    \begin{cases}
      1, & \text{if}\ n = kT, k=0,1,... \\
      0, & \text{otherwise}
    \end{cases}
\end{equation}

\begin{equation}
\label{eqn:sys_complete}
    complete_s(n) =
    \begin{cases}
      1, & \text{if}\ n = kT-1, k=1,2,... \\
      0, & \text{otherwise}
    \end{cases}
\end{equation}

Verifying a system satisfies its contract $(A_s, p_s)$ is to check whether the set of traces of the contract is a subset of the oberservable traces of the system. TODO

{\bf Hierarchical Composition.}
The proposed semantics supports hierarchical composition and Hierarchical Scheduling Framework (HSF) \cite{HSF}. This is possible if the structural proximity of the models is coincidental with the temporal proximity of their time slots in a schedule. We illustrate this using the example shown in Figure \ref{pic:hierarchy}. A system $G$ consists of components $A$ and $B$. Suppose given the lower-level schedule $(ABA)$, we prove the contracts of $G$. Then, at the structural higher-level, $G$ could be viewed as a component. And since component $A$ and $B$ are also scheduled to execute one after another, $G$'s time slot is the concatenation of the time slots of its components. Thus its \emph{dispatch} and \emph{complete} events is the start and end of the combined time slot, respectively.

\begin{figure}[ht!]
\centering
\includegraphics[width=100mm]{Hierarchy.jpg}
\caption{An Example of Hierarchical Composition in AGREE\label{pic:hierarchy}}
\end{figure}

Note that if all the inputs of a component are connected to the outputs of other components, the inputs value will not change while the component is active. This is because the other components hold their outputs while inactive. It implies assumptions could be checked at \emph{complete}, instead of \emph{dispatch}. Thus, we do not necessarily need \emph{dispatch} event for verification purposes. Actually, in the backend implementation, assumptions at checked at \emph{complete}. We keep \emph{dispatch} event mainly for usability reasons. The (\emph{dispatch, complete}) pair helps users to understand a counterexample and mentally construct the system trace. This is particularly useful when the schedule is preemptive .

{\bf Model of Real-Time Schedule.}
In practice, a schedule often comes in form of real-time schedule, a sequence of time slots associated wtih components. The real-time schedule could come from an AADL scheduling tool like Cheddar \cite{Cheddar}, or from a scheduler provided by the RTOS/Microkernel verdor, like seL4\cite{seL4}. To properly model the schedule in AGREE, the component execution time has to be considered. One example is shown in Figure \ref{RTschedule}, where there are two components $A$ and $B$. 
\begin{figure}[ht!]
\centering
\includegraphics[width=130mm]{RTschedule.jpg}
\caption{A Model of Real-Time Schedule in AGREE\label{RTschedule}}
\end{figure}
Given the same real-time schedule, due to the different execution time $C_A$ of $A$, different AGREE schedules are created. In Figure\ref{RTschedule}(b), since the first time slot assigned for $A$ is less than its execution time, the end of the first time slot is interpreted as \emph{preemption}, instead of \emph{complete}.

We introduce a circular counter to model a schedule in AGREE. The maximum count models the period of the schedule. An AGREE model of the schedule $(ABACD)^*$ used in the example is shown in Figure \ref{schedule}.
\begin{figure}[ht!]
\centering
\includegraphics[width=100mm]{schedule.jpg}
\caption{A Model of Schedule in AGREE\label{schedule}}
\end{figure}


%An AGREE model of the schedule $(ABACD)^*$ used in the example is shown in code~\ref{schedule_model}

%\begin{lstlisting}[language=c,frame=single,caption=An AGREE model of a schedule,label=schedule_model]
%node CircularCounter (init: int, incr: int, reset: bool)	
%returns (count: int);
%let
%	count = if reset then init
%		else init-> (pre(count) + incr);
%tel;
%				
%eq tick : int = CircularCounter(1,1,prev(tick=10,false));
%
%assume "Schedule ABACD" :
%	A_dispatch = (tick = 1 or tick = 5) and
%	A_complete = (tick = 2 or tick = 6) and					
%	B_dispatch = (tick = 3) and	
%	B_complete = (tick = 4) and
%	C_dispatch = (tick = 7) and
%	C_complete = (tick = 8) and	
%	D_dispatch = (tick = 9) and
%	D_complete = (tick = 10);			
%\end{lstlisting}	

%The model of a schedule can be simplified to potentially improve the formal verification performance. The thread execution time can be modelled as just one tick. The idle time or communication delay can be abstracted out. For the same example above, a simplified schedule could be  $\phi' = \{d(A)=(1,0,0)^*, c(A) = (0,1,0)^*, d(B) = (0,1,0)^*, c(B) = (0,0,1)^*\}$. The intuition is that as long as the execution order is preserved, the verfication problem of such a model is equavilent to that of a model directly mapping each base time unit to a tick. 
%	
%\begin{theorem}
%Given an AADL model with two \emph{equavilent} schedules $\phi$ and $\phi'$, a property of the model holds under schedule $\phi$ if and only if it hold under schedule $\phi'$.
%\end{theorem}
%
%{\bf Proof sketch.} 
%It is possible to show that any counter-example found in the proof of the system property of model with schedule $\phi$ can be mapped to a counter-example of the proof of the same system property of the same model with schedule $\phi'$,  and vice versa.  

{\bf External Input.} 
System inputs from the environment could arrive at any instant, while the system runs periodically. To avoid missing events, we assume that there is a buffer mechanism that stores all the input messages on a queue and periodically send it out to the system for processing. We assume the communication can be modelled as a shared variable, and the communication rate is the same as the system execution rate. 

%\documentclass{article}
%\usepackage{multirow}
%\begin{document}
%\begin{center}
%\begin{tabular}{ |c|c|c|c|c|c|c|c|c|c|c|c| } 
%\hline
%k & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
%\hline
%& Active & - & A & B & A & C & D & A & B & A & C & D \\ 
%\hline
%\end{tabular}
%\end{center}
%\end{document}

%As suggested by previous examples, the schedule or execution order has an impact on the system behavior. This differs from other dataflow models, such as Synchronous Dataflow \cite{sdf}, or other variants of Kahn Process Networks \cite{kpn}. It is known 

%{\bf model of execution delay.}
%The thread exeution delay is not directly modelled. Instead, the time slot allocated to a thread in a schedule is modelled by the \emph{distance} between the thread \emph{dispatch} and \emph{complete}. If we assume there is no pre-emption, this modells  the worst case execution time or deadline.

%{\bf model of communication delay.}
%The communication delay is abstracted out. However, in a schedule there is often a time window between the complete event of the one thread and the dispatch event of the next thread. This time window models the %worst case communication delay.

%{\bf AGREE contracts.}

%Our approach to modelling the AADL asynchronous MoC in AGREE is to keep the existing AADL model structure intact and add new AGREE contracts and augument existing contracts. The added contracts model the asynchronous communication between AADL ports. The modification of the exisiting contracts reflcts the interpretation of the contracts under the asychronous AGREE MoC. 

%\begin{figure}[ht!]
%\centering
%\includegraphics[width=80mm]{aadl_events.jpg}
%\caption{An AADL Model with AGREE Contracts\label{motivation}}
%\end{figure}

%In asynchronous AGREE, the \emph{Execution\_Time} property is modelled by the time interval between the \emph{Dispatch} event and the \emph{Complete} event.
%The assumptions hold at the \emph{Dispatch} event \[Dispatch => Assumption\] , and the guarantees hold at the \emph{Complete} event, i.e. \[Complete => Guarantee\] 
%
%% Assumptions
%We make the following assumptions. The \emph{Input\_Time} property value is unspecified, thus default to dispatch time. The \emph{Output\_Time} property value is unspecified, thus default to the execution completion time. The \emph{Queue\_Size} property value is unspecified, thus default to size one. The \emph{Execution\_Time} property represent a single value, not a real range. The \emph{Dispatch\_Protocol} property value is periodic. The \emph{Timing} property value of each connection is unspecified, thus default to immediate connection. There is no simultaneous read and write access to a queue or buffer (data port). If an event data queue or a data port buffer is empty, the most recent data is used. The \emph{Dequeue} occurs at every dispatch. There is no preemption. There is no propagation delay.
%
%% Modelling
%For an output event data port of a thread, the event and data holds till the thread's next \emph{Complete} event. This is represented by the following AGREE contracts.
%
%\begin{math} 
%not Complete => (event(Port) = prev(event(Port), false))
%\end{math} 
%
%\begin{math}
%not Complete => (true -> (Port = pre(Port)))
%\end{math}  
%
%% Rational
%The output event hold models the latching behavior of an event queue (size one). At the end of execution of a thread, an output event may or may not be raised. However, the AGREE contracts representing the functional requirements only ensures an event is raised only at that exact time instant (i.e. \emph{Complete}). The event is latched so that the target thread, once dispatched, samples the correct result. The consideration for the output data hold is similar.
% 
%% Schedule
%In asynchronous AGREE, a schedule defines the sequential execution order of threads. It is specified by the user. It often come from the actual software execution schedule on the target platform (e.g. seL4 domain schedule). Currently AADL does not define a standard format to specify a schedule. We used AGREE \emph{assumption} on each thread's \emph{Dispatch} and \emph{Complete} event to represent a schedule. For example, \emph{assume "schedule" :			ThreadA\_Dispatch = (Frame = 60) and ThreadA\_Complete = (Frame = 70) and ...}

