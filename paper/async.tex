{\bf Signal.}
A signal $x$ is a function $x: N \rightarrow V$, where $N$ is the set of natural numbers including zero, and $V$ is a value set. 
A signal is \emph{Boolean} if the value set is the Boolean domain.
We use $x(n)$ to denote the value of the signal $x$ at instant $n$. 
%A \emph{trace} $\sigma_x$ of a signal $x$ is a possibly infinite sequence of values $(x(1), x(2),... )$. 
%We use $X_V$ to denote the set of all possible signals for a value set $V$.
%The \emph{length} of a trace is the number of elements in the sequence. 
%The length-$k$ trace of a signal $x$ is denoted as $x^k$.
%The set of the length-$k$ traces of a set $X$ of signals is denoted as $X^k$.
%The set of all possible traces of a signal $x$ is denoted as $x^{\omega}$. 
%The set of all possible traces of a set $X$ of signals is denoted as $X^{\omega}$. 

{\bf Port.}
%Let $Q ={q_1, ...,q_M}$ be a set of ports, where $q_i$ is the name of the i-th port. 
Let $Q$  be a set of ports. 
For each port $q \in Q$, a set $V_q$ denotes the values that may be assigned to port $q$. %$V_q$ is called the type of port $q$. 
%A \emph{valuation} of $Q$ is an assignment of a value in $V_q$ to each port $q \in Q$.
A signal $x_q$ of a port $q$ is a function $x_q: N \rightarrow V_q$.
A \emph{trace} $\sigma_Q$ of $Q$ is an assignment of a signal $x_q$ to each port $q$ in $Q$.
We use $\Sigma_Q$ to denote the set of all traces of $Q$.
Given a set $Q' \subseteq Q$, the \emph{projection} of a trace $\sigma_Q$ onto $Q'$ is the assignment of signal $x_q$ to each port $q$ in $Q'$ defined in $\sigma_Q$, as defined in $\sigma_Q$. We denote the projection as $\sigma_Q|_{Q'}$.
 
{\bf Dispatch and Complete.}
Two Boolean signals \emph{dispatch} and \emph{complete} are \emph{well-ordered} if 

\begin{enumerate}
%	\item $ \nexists n\in N, dispatch(n) = 1 \text{ and } complete(n) =  1 $, 
	\item $\forall n \in N, dispatch(n) \ne 1 \vee complete(n) \ne 1 $,
	\item $ \forall n\in N, dispatch(n) = 1 \Rightarrow \exists m\in N, m > n, complete(m) =  1 $,
	\item $ \forall m\in N, complete(m) = 1 \Rightarrow \exists n\in N, m > n, dispatch(n) =  1 $,
	\item $ \forall n,m\in N, n \neq m, dispatch(n) = 1, dispatch(m) = 1 \Rightarrow \exists k\in N, m >k> n, complete(k) = 1 $.
\end{enumerate}

The first condition states that \emph{dispatch} and \emph{complete} are mutual exclusive. The second and third condition state that \emph{dispatch} and \emph{complete} appear in pairs, and in each pair \emph{dispatch} appears before \emph{complete}. The fourth condition states that \emph{dispatch} and \emph{complete} appear alternately. 
From hereon we only consider a well-ordered pair (\emph{dispatch}, \emph{complete}).

An \emph{interval} $\delta$ of a pair (\emph{dispatch}, \emph{complete}) is a set of integers $[n, m] \cap N, n,m \in N, m>n$, satisfying:

\begin{enumerate}
	\item $ dispatch(n) = 1 $, 
	\item $ complete(m) = 1 $, 
	\item $ \forall k\in (n, m) \cap N, dispatch(k)=0 \wedge complete(k)=0 $.
\end{enumerate}

We denote the set of all such intervals as $\Delta$.

{\bf Component.}
A component $c$ is a tuple $(I_c, O_c, A_c, P_c, dispatch_c, complete_c)$, where: 

\begin{itemize}
    	\item $I_c$ is a finite set of ports, called \emph{inputs},
    	\item $O_c$ is a finite set of ports disjoint from $I_c$, called \emph{outputs},
%	\item $\Sigma_c \subseteq \Sigma_{I_c \cup O_c}$, called behavior,
%	\item $A_c$ and $P_c$ are prefix-closed subsets of $(I_c \cup O_c)^\omega$, called \emph{assumptions} and \emph{guarantees}, respectively,
%	\item $A_c$ and $P_c$ are two Boolean functions $(I_c \cup O_c)^\omega \rightarrow B$, called \emph{assumptions} and \emph{guarantees}, respectively,	
	\item $A_c$ and $P_c$ are two Boolean functions $\Sigma_{I_c \cup O_c} \rightarrow B$, called \emph{assumptions} and \emph{guarantees}, respectively,	
    	\item ($dispatch_c$, $complete_c$) is a pair of \emph{well-ordered} Boolean signals.
\end{itemize}
%A \emph{trace} $\sigma_c$ of a component $c$ is an assignment of a signal $x_q$ to each port $q$ in $I \cup O$.

%Let $\mathcal{A}_c$ be a function $(I_c \cup O_c)^\omega \rightarrow B$, such that $\forall \Sigma \in A_c, \mathcal{A}_c(\Sigma) = 1$.
%Let $\mathcal{P}_c$ be a function $(I_c \cup O_c)^\omega \rightarrow B$, such that $\forall \Sigma \in P_c, \mathcal{P}_c(\Sigma) = 1$.

%A component is said to be \emph{consistent} if it satisfies the following rules.
%A component satisfies the following rules.
%Given a component $c$ and a trace $\sigma_c \in \Sigma_{I_c \cup O_c}$, we define the following propositions:

The \emph{behavior} of a component $c$ is a set $\Sigma_c \subseteq \Sigma_{I_c \cup O_c}$, such that for all trace $\sigma_c \in \Sigma_c$ the following propositions hold.
%A component $c$ is said to be \emph{consistent} if for all $\sigma_c \in \Sigma_c$ the following propositions hold.

The \emph{assumptions} hold at \emph{dispatch}. That is,
\begin{equation} 
\label{eqn:assumption}
%	dispatch_c(n) \Rightarrow A((I_c \cup O_c)^n), \forall n\in N.
	dispatch_c(n) \Rightarrow (\sigma_c, n) \models A_c, \forall n\in N.
\end{equation}

Inputs freeze between \emph{dispatch} and \emph{complete}. That is,
\begin{equation} 
\label{eqn:inputfreeze}
	x(i) = x(j), \forall i,j\in \delta \cap N, \forall \delta \in \Delta, \forall x \in \sigma_c|_{I_c}.
\end{equation}

The \emph{guarantees} hold at \emph{complete}. That is,
\begin{equation} 
\label{eqn:guarantee}
%	complete_c(n) \Rightarrow P((I_c \cup O_c)^n), \forall n\in N.
	complete_c(n) \Rightarrow (\sigma_c, n) \models P_c, \forall n\in N.
\end{equation}

Outputs freeze between \emph{completes}. That is,
\begin{equation} 
\label{eqn:outputfreeze}
	\lnot complete_c(n) \Rightarrow y(n) = y(n-1), \forall n \in N, n > 0, \forall y \in \sigma_c|_{O_c}.
\end{equation}

{\bf Schedule.}
Two components $ c, c', c\neq c'$ are said to be \emph{connected} if
\begin{equation*}
	O_c \cap I_{c'} \neq \emptyset \vee O_{c'} \cap I_c \neq \emptyset.
\end{equation*}

Let $C$ be a finite set of components, a schedule $\phi$ of $C$ with \emph{length} $T\in N$ is a partial function $[1, T]  \cap N\rightarrow C\times \{\textsf{Dispatch}, \textsf{Complete}\}$ satisfying:

\begin{enumerate}
	\item $ \forall i\in \text{dom }\phi, c\in C, \phi(i) = (c, \textsf{Dispatch}) \Rightarrow \exists j\in \text{dom }\phi, j > i, \phi(j) =  (c, \textsf{Complete}) $,
	\item $ \forall j\in \text{dom }\phi, c\in C, \phi(j) = (c, \textsf{Complete}) \Rightarrow \exists i\in \text{dom }\phi, j > i, \phi(i) =  (c, \textsf{Dispatch}) $,
	\item $ \forall i, j\in \text{dom }\phi, c\in C, i \neq j, \phi(i) = (c, \textsf{Dispatch}), \phi(j) = (c, \textsf{Dispatch}) \Rightarrow \exists k\in \text{dom }\phi, j >k> i, \phi(j) =  (c, \textsf{Complete}) $,
	\item $ \forall i, j, n\in \text{dom }\phi, i < n < j, c, c'\in C, \phi(i) = (c, \textsf{Dispatch}), \phi(n) = (c', \textsf{Dispatch}), \phi(j) = (c, \textsf{Complete}) \Rightarrow c, c' \text{ are not connected, and }\exists m\in \text{dom }\phi, n < m < j, \phi(m) =  (c', \textsf{Complete}) $.
\end{enumerate}

The first three conditions ensure the pair (\textsf{Dispatch}, \textsf{Complete}) associated with a component is \emph{well-ordered} in a schedule. 
The fourth condition allows a component to be \emph{preempted} by another component if they two have no connection.
If the schedule is not preemptive, we could simplify the notation and denote a schedule as a function that maps $[1, T] \cap N$ to $C$, as shown in the previous examples.
A schedule is \emph{minimal} if $\phi$ is a \emph{total} function. This means that at each instant either a \emph{dispatch} or a \emph{complete} signal evaluates to true. 
A schedule is \emph{fair} if $\phi$ is \emph{surjective}. This means that every component is scheduled to execute at least once.
%In our framework, we only consider fair schedules.

Given a schedule $\phi$ of components $C$, the \emph{dispatch} and \emph{complete} signal of each component $c \in C$ are defined as follows: $\forall i \in N$,
\begin{equation*}
\label{eqn:dispatch}
    dispatch_c^\phi(i) =
    \begin{cases}
      1, & \text{if } \phi(i \mod T) = (c, \textsf{Dispatch}) \\
      0, & \text{otherwise}
    \end{cases},
\end{equation*}

\begin{equation*}
\label{eqn:complete}
    complete_c^\phi(i) =
    \begin{cases}
      1, & \text{if } \phi(i \mod T) = (c, \textsf{Complete}) \\
      0, & \text{otherwise}
    \end{cases}.
\end{equation*}

{\bf System.}
A set $C$ of components are said to be \emph{compatible} if 
\begin{equation*}
	\forall c_i,c_j \in C, c_i\neq c_j, O_{c_i} \cap O_{c_j} = \emptyset.
\end{equation*}
A set $C$ of components are said to be \emph{connected} if
\begin{equation*}
	\forall c_i \in C, \exists c_j \in C, c_i\neq c_j, O_{c_i} \cap I_{c_j} \neq \emptyset \vee O_{c_j} \cap I_{c_i} \neq \emptyset.
\end{equation*}
%A set $C$ of compatible, connected, scheduled components is a \emph{system} $S = (I_s, O_s, A_s, P_s, \phi, dispatch_s, complete_s)$, where:
A set $C$ of compatible, connected, scheduled components is a \emph{system} $S = (I_s, O_s, A_s, P_s, dispatch_s, complete_s)$, where:
\begin{itemize}
	\item $I_s = \cup_{\forall c \in C}I_c -  \cup_{\forall c \in C}O_c$,
	\item $O_s = \cup_{\forall c \in C}O_c$,
	\item $A_s$ and $P_s$ are two Boolean functions $\Sigma_{I_s \cup O_s} \rightarrow B$, called system-level \emph{assumptions} and \emph{guarantees}, respectively,
%	\item $\phi$ is a schedule of $C$,	
	\item $dispatch_s (i) = 
	    	\begin{cases}
      		1, & \text{if}\ i \mod T =1 \\
	     	0, & \text{otherwise}
   	 	\end{cases}, \forall i \in N$,
   	\item $complete_s (i) =
   		\begin{cases}
      		1, & \text{if}\ i \mod T = 0 \\
	     	0, & \text{otherwise}
   	 	\end{cases}, \forall i \in N, i > 0$.
\end{itemize}
The \emph{behavior} of a system $S$ is a set $\Sigma_s \subseteq \Sigma_{I_s \cup O_s}$ satisfying: 
\begin{equation*}
	\forall \sigma_s \in \Sigma_s,  \forall c \in C, \exists \sigma_c \in \Sigma_c, \sigma_s|_{I_c \cup O_c} = \sigma_c.
\end{equation*}

We use $\delta_s$ to denote an \emph{interval} of the pair ($dispatch_s, complete_s$). We use $\Delta_s$ to denote the set of all such intervals.
We define the following propositions.

The \emph{assumptions} hold at \emph{dispatch}. That is,
\begin{equation} 
\label{eqn:assumption}
	dispatch_s(n) \Rightarrow (\sigma_s, n) \models A_s, \forall n\in N.
\end{equation}

Inputs freeze between dispatch and complete. That is,
\begin{equation} 
\label{eqn:inputfreeze}
	x(i) = x(j), \forall i,j\in \delta_s \cap N, \forall \delta_s \in \Delta_s, \forall x \in \sigma_s|_{I_s}.
\end{equation}

The \emph{gurarantees} hold at \emph{complete}. That is,
\begin{equation} 
\label{eqn:guarantee}
	complete_s(n) \Rightarrow (\sigma_s, n) \models P_s, \forall n\in N.
\end{equation}

Note that we do not define the system output freeze rule. This is because in our context, the system under consideration is always active. The rule would make sense in the assume-guarantee reasoning at a higher level in the hierarchy, where the system under consideration is viewed as a component and activated periodically.
