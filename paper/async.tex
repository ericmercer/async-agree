{\bf Signal.}
A signal $x$ is a function $x: N \rightarrow V$, where $N$ is the set of natural numbers, and $V$ is a value set. 
A signal is \emph{Boolean} if the value set is the Boolean domain.
We write $x(n)$ for the value of the signal $x$ at instant $n$. 
A \emph{trace} $\sigma_x$ of a signal $x$ is a possibly infinite sequence of values $(x(1), x(2),... )$. 
The \emph{length} of a trace is the number of elements in the sequence. 
The set of all traces of length $k$ of a signal $x$ is denoted as $x^k$. 
The set of all possible traces of a signal $x$ is denoted as $x^{\omega}$. 
The set of all possible traces of a set $X$ of signals is denoted as $X^{\omega}$. 

{\bf Dispatch and Complete.}
Two Boolean signals \emph{dispatch} and \emph{complete} are \emph{well-ordered} if 

\begin{enumerate}
%	\item $ \nexists n\in N, dispatch(n) = 1 \text{ and } complete(n) =  1 $, 
	\item $\forall n \in N, dispatch(n) \ne 1 \vee complete(n) \ne 1 $,
	\item $ \exists n\in N, dispatch(n) = 1 \text{ if and only if } \exists m\in N, m > n, complete(m) =  1 $,
	\item $ \text{if } \exists n,m\in N, n \neq m, dispatch(n) = 1, dispatch(m) = 1, \text{ then } \exists k\in N, m >k> n, complete(k) = 1 $.
\end{enumerate}

The first condition states that \emph{dispatch} and \emph{complete} are mutual exclusive. The second condition states that \emph{dispatch} and \emph{complete} appear in pairs, and in each pair \emph{dispatch} appears before \emph{complete}. The third condition states that \emph{dispatch} and \emph{complete} appear alternately. 
From hereon we only consider well-ordered (\emph{dispatch}, \emph{complete}).

An \emph{interval} $\delta$ of a pair (\emph{dispatch}, \emph{complete}) is a closed interval $[n, m], n,m \in N, m>n$, satisfying

\begin{enumerate}
	\item $ dispatch(n) = 1 $, 
	\item $ complete(m) = 1 $, 
	\item $ \forall k\in (n, m), dispatch(k)=0 \text{ and } complete(k)=0 $.
\end{enumerate}

We denote the set of all intervals as $\Delta$.

{\bf Component.}
A component $c$ is a tuple $(I, O, A, P, dispatch, complete)$, where: 

\begin{itemize}
    	\item $I$ is a finite set of signals, referred to as inputs, also denoted as $I(c)$,
    	\item $O$ is a finite set of signals disjoint from $I$, referred to as outputs, also denoted as $O(c)$,
	\item $A$ and $P$ are prefix-closed subsets of $(I \cup O)^\omega$, called \emph{assumptions} and \emph{guarantees}, respectively,
    	\item ($dispatch$, $complete$) is a pair of \emph{well-ordered} Boolean signals.
\end{itemize}

A component is said to be \emph{consistent} if it satisfies the following rules.

The \emph{assumptions} hold at \emph{dispatch}. That is,
\begin{equation*} 
\label{eqn:assumption}
	dispatch(n) \Rightarrow a(I^n, O^n), \forall n\in N, \forall a \in A
\end{equation*}

Inputs freeze between dispatch and complete. That is,
\begin{equation*} 
\label{eqn:inputfreeze}
	x(i) = x(j), \forall i,j\in \delta, \forall \delta \in \Delta, \forall x \in I
\end{equation*}

The \emph{guarantees} hold at \emph{complete}. That is,
\begin{equation*} 
\label{eqn:guarantee}
	complete(n) \Rightarrow p(I^n, O^n), \forall n\in N, \forall p \in P
\end{equation*}


Outputs freeze between \emph{completes}. That is,
\begin{equation*} 
\label{eqn:outputfreeze}
\lnot complete(n) \Rightarrow y(n) = y(n-1), \forall n \in N, n>0, \forall y \in O
\end{equation*}

{\bf Schedule.}
Two components $ c, c', c\neq c'$ are said to be \emph{connected} if
\begin{equation*}
	O(c) \cap I(c') \neq \emptyset \text{ or } O(c') \cap I(c) \neq \emptyset.
\end{equation*}

Let $C$ be a finite set of components, a schedule $\phi$ of $C$ with \emph{length} $T\in N$ is a partial function $[1, T] \rightarrow C\times \{Dispatch, Complete\}$ satisfying:

\begin{enumerate}
	\item $ \exists i\in T, c\in C, \phi(i) = (c, Dispatch) \text{ if and only if } \exists j\in T, j > i, \phi(j) =  (c, Complete) $,
	\item $ \text{if } \exists i, j\in T, c\in C, i \neq j, \phi(i) = (c, Dispatch), \phi(j) = (c, Dispatch), \text{ then } \exists k\in T, j >k> i, \phi(j) =  (c, Complete) $,
	\item $ \text{if } \exists i, j, n\in T, i < n < j, c, c'\in C, \phi(i) = (c, Dispatch), \phi(n) = (c', Dispatch), \phi(j) = (c, Complete), \text{ then } c, c' \text{ are not connected, and }\exists m\in T, n < m < j, \phi(m) =  (c', Complete) $.
\end{enumerate}

The first two conditions define the patterns of (Dispatch, Complete) in a schedule. 
The third condition allows a component to be \emph{preempted} by another component if they two have no connection.
If the schedule is not preemptive, we could simplify the notation and denote a schedule as a function $[1, T] \rightarrow C$, as shown in the previous examples.

Given a schedule $\phi$ of components $C$, the \emph{dispatch} and \emph{complete} signal of a component $c \in C$ are defined as follows: 
\begin{equation*}
\label{eqn:dispatch}
    dispatch_c^\phi(i+kT) =
    \begin{cases}
      1, & \text{if}\ \phi(i) = (c, Dispatch) \\
      0, & \text{otherwise}
    \end{cases}
\end{equation*}

\begin{equation*}
\label{eqn:complete}
    complete_c^\phi(i+kT) =
    \begin{cases}
      1, & \text{if}\ \phi(i) = (c, Complete) \\
      0, & \text{otherwise}
    \end{cases}
\end{equation*}

where $i,k\in N$. 
A schedule is \emph{minimal} if $\phi$ is a \emph{total} function. This means that at each instant either a \emph{dispatch} or a \emph{complete} signal evaluates to true. 
A schedule is \emph{fair} if $\phi$ is \emph{surjective}. This means that every component is scheduled to execute at least once.
In our framework, we only consider fair schedules.

{\bf System.}
A set $C$ of components are said to be \emph{compatible} if 

\begin{equation*}
\forall c_i,c_j \in C, c_i\neq c_j, O(c_i) \cap O(c_j) = \emptyset.
\end{equation*}

A set $C$ of components are said to be \emph{connected} if
\begin{equation*}
\forall c_i \in C, \exists c_j \in C, c_i\neq c_j, O(c_i) \cap I(c_j) \neq \emptyset \text{ or } O(c_j) \cap I(c_i) \neq \emptyset.
\end{equation*}

A set $C$ of compatible, connected, scheduled, and consistent components is a \emph{system} $S = (I, O, A, P, \phi)$, where:
\begin{itemize}
	\item $I = \cup_{\forall c \in C}I(c) -  \cup_{\forall c \in C}O(c)$, also denoted as $I(S)$,
	\item $O = \cup_{\forall c \in C}O(c)$, also denoted as $O(S)$,
	\item $A$ and $P$ are \emph{assumptions} and \emph{guarantees} over $(I \cup O)^\omega$, respectively,
	\item $\phi$ is a schedule of $C$.	
\end{itemize}