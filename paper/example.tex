\begin{figure}[ht!]
\centering
\includegraphics[width=60mm]{simpleFeedback.jpg}
\caption{A Simple Feedback System\label{motivationFig1}}
\end{figure}

First, we will explain the intuition and illustrate the key semantic difference between the synchronous model used in the original AGREE framework and the proposed model.
Consider an AADL model that consists of two threads $A$ and $B$, shown in Figure \ref{motivationFig1}. Assume all ports are data ports. The behavior of each thread is indicated by its AGREE contract. Thread $A$ output doubles its input. Thread $B$ output increments its input by one. By the synchronous model semantics, the value of signal $x$ and $y$ at instant $n$ is defined by the solution to the two equations $y_n = 2x_n$ and $x_n = y_n+1$, for all $n \in N$. This results in $x = (-1, -1, …)$, $y = (-2, -2, …)$. However, if the two threads execute in a sequential order $(ABAB...)$, and let $x_0, y_0$ denote the initial value of $x$ and $y$, respectively, an intuitive interpretation of the execution semantics is $y_1 = 2x_0, x_1 = y_1+1, y_2 = 2x_1...$. If $x_0 = 0$ and  $y_0 = 0$, this results in $x = (0, 1, 3, 7,…)$ and $y = (0, 0, 2, 6, …)$. The example shows that the behavior of a synchronous model is defined by the solution(s) to systems of mathematical equations (or inequalities) at each instant, while the behavior of the scheduled components is defined through iterations over time. 

\begin{figure}[ht!]
\centering
\includegraphics[width=80mm]{downsample.jpg}
\caption{A Simple Downsampling System\label{motivationFig2}}
\end{figure}

Now we will illustrate the motivation of our work.
Consider an AADL model that consists of four threads $A, B, C, D$, shown in Figure \ref{motivationFig2}. Assume all ports are data ports. Thread $A$ outputs the sequence of all natural numbers. Thread B and thread C simply copy its input to the output. Thread D subtracts the second (bottom) input value from the first (top) input value. Given a schedule $(ACABD)^*$, let us say we want to prove that the primary output $d$ is a sequence of ones (ignoring the initial prefix). This can be achieved with the proposed model, since thread $B$ only copies even numbers, and thread $C$ only copies odd numbers. However, it cannot be proved directly with the synchronous model, where $d$ is a sequence of zeroes. To model execution order in a synchronous model, a special construct \emph{delay} is often introduced. However, in the example, thread $B$ and $C$ essentially downsample the data stream from thread $A$. To model this kind of behavior (e.g. downsampling or upsampling), it requires much more complicated modeling mechanism than simple \emph{delays}. 

Note that if the schedule is $(ABCD)^*$, the output $d$ is a sequence of zeroes (ignoring the initial prefix), matching the behavior of the synchronous model. This indicates that the execution order could have an impact on the system behavior. As we will show later, our model is not a variant of Kahn Process Network \cite{KPN}, like Lee's Synchronous Dataflow \cite{SDF}, where any execution order results in the same system behavior. Therefore, it makes sense to tie a system-level property to a specific schedule of the components.
%Also note that we could add \emph{assumption: input is an even number} to thread $B$. The assumption has no impact on the system behavior under the proposed MoC. However, under the synchronous AGREE MoC the system has no valid behavior. This is because the assumption is violated under the synchronous semantics. This kind of assumptions are not uncommon. It creates a modelling challenge for using synchronous models. 


 
  