The AADL standard by iteself does not have a well-defined execution semantics. In order to formally verify an AADL model, it is often translated to a formal model \cite{AADL2TASM} \cite{AADL2Sync} \cite{AADL2TLA} \cite{AADS} \cite{AADL2BIP}. Then a formal method is applied to analyze the translated model.

%Model checking of concurrent processes with specific schedules or scheduling constraints is a relatively new research area. 
Metzler et al. \cite{Metzler2020} use an iterative and incremental approach to prove safety properties of concurrent programs. It starts with a proof under a specific schedule, and then in each following iteration gradually relaxes the scheduling constraints. The iteration stops when all possible exections are explored or a counterexample is generated. Unlike our component model, their programs are ``white boxes'', allowing their schedule to interleave instructions between programs. In comparison, our basic scheduling unit is a software thread. In each iteration, the model checking problem is still challenging. In this context, our compositional verification approach makes sense.

In \emph{aadl2sync} \cite{AADL2Sync}, the AADL behavior models are translated to synchronous programs mainly for simulation. It uses activation condition to model sporadic execution of software components, similar to our usage of \emph{condact}. However, the proposed framework focuses on simulating the detailed timed behavior with the presence of clock drift. Meanwhile, we focus on the formal verification of system properties based on component requirements, which in general do not completely define component behavior.

